# SimpleFileSystem
This was a Final project for Operating Systems class at McGill University where the purpose was to implement a **Mountable Simple File System**. The "simple" comes from the provided disk emulation provided by the proffessor which allowed me to emulate the file system with purely software. However, such restrictions should be reasonable to not oversimplify the implementation and should be documented in your submission. Even with the said restrictions, the file system you are implementing is highly useable for embedded applications.The SFS introduces many limitations such as restricted filename lengths, no user concept, no protection among files, no support for concurrent access, etc.

## There were a few components to this file system:
### **Objectives in detail**
In reality, you could implement the SFS with your own API that implements the necessary functions to interface with the FUSE wrapper provided as part of this assignment. However, for debugging purposes, we suggest that you implement your file system such that it exposes the following API. The additional test suite we provide with the assignment could be used to test your file system if you stick to the proposed API. You can deviate even significantly from the proposed API; however, in that case you will be responsible for modifying the test suite.
The suggested API for SFS is given below. The API is based on C language. It is strongly suggested that you retain the functionality provided by the API if you decide to change it.
### void mksfs(int fresh); // creates the file system
### int sfs_getnextfilename(char *fname);  // get the name of the next file in directory
### int sfs_getfilesize(const char* path); // get the size of the given file
### int sfs_fopen(char *name);  int sfs_fread(int fileID
### int sfs_fclose(int fileID); // closes the given file
### int sfs_fwrite(int fileID, char *buf, int length); // write buf characters into disk
### int sfs_fread(int fileID, char *buf, int length); // read characters from disk into buf
### int sfs_fseek(int fileID, int loc); // seek to the location from beginning 
### int sfs_remove(char *file);// removes a file from the filesystem


The mksfs() formats the virtual disk implemented by the disk emulator and creates an instance of the simple file system on top of it. The mksfs() has a fresh flag to signal that the file system should be created from scratch. If flag is false, the file system is opened from the disk (i.e., we assume that a valid file system is already there in the file system. The support for persistence is important so you can reuse existing data or create a new file system.
The sfs_getnextfilename(char *fname) copies the name of the next file in the directory into fname and returns non zero if there is a new file. Once all the files have been returned, this function returns 0. So, you should be able to use this function to loop through the directory. In implementing this function, you need to ensure that the function remembers the current position in the directory at each call. Remember in SFS we have a single-level directory. The sfs_getfilesize(char *path) returns the size of a given file.
The sfs_fopen() opens a file and returns the index that corresponds to the newly opened file in the file descriptor table. If the file does not exist, it creates a new file and sets its size to 0. If the file exists, the file is opened in append mode (i.e., set the file pointer to the end of the file). The sfs_fclose() closes a file, i.e., removes the entry from the open file descriptor table. On success, sfs_fclose() should return 0 and a negative value otherwise. The sfs_fwrite() writes the given number of bytes of buffered data in buf into the open file, starting from the current file pointer. This in effect could increase the size of the file by the given number of bytes (it may not increase the file size by the number of bytes written if the write pointer is located at a location other than the end of the file). The sfs_fwrite() should return the number of bytes written. The sfs_fread() follows a similar behavior. The sfs_fseek() moves the read/write pointer (a single pointer in SFS) to the given location. It return 0 on success and a negative integer value otherwise. The sfs_remove() removes the file from the directory entry, releases the file allocation table entries and releases the data blocks used by the file, so that they can be used by new files in the future.
A file system is somewhat different from other components because it maintains data structures in memory as well as disk! The disk data structures are important to manage the space in disk and allocate and de-allocate the disk space in an intelligent manner. Also, the disk data structures indicate where a file is allocated. This information is necessary to access the file.
3. Implementation strategy
The disk emulator given to you provides a constant-cost disk (CCdisk). This CCdisk can be considered as an array of sectors (blocks of fixed size). You can randomly access any given sector for reading or writing. The CCdisk is implemented as a file on the actual file system. Therefore, the data you store in the CCdisk is persistent across program invocations. To mimic the real disk, the CCdisk is divided into sectors of fixed size. For example, we can split the space into 1024 byte sectors. The number of sectors times the size of a sector gives the total size of the disk. In addition to holding the actual file and directory data, we need to store auxiliary data (meta data) that describes the files and directories in the disk. The structure and number of bytes spent on meta data storage depends on the file system design, which is the concern in this assignment.
